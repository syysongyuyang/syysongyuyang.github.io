<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BSGS</title>
    <url>/2023/02/11/BSGS/</url>
    <content><![CDATA[<p>BSGS,解决离散对数问题</p>
<span id="more"></span>
<h2 id="BSGS-解决离散对数问题"><a href="#BSGS-解决离散对数问题" class="headerlink" title="$BSGS$:解决离散对数问题"></a>$BSGS$:解决离散对数问题</h2><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>求$a^x\equiv b \pmod p$的最小正整数解$x$</p>
<p>性质：$\gcd(a,p)=1$</p>
<h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><p><del>自然是可以大力枚举$x$！再套上指令集+循环展开就可以切了</del></p>
<p>我们定义$x=A\left \lceil p \right \rceil - B$</p>
<p>所以原式变成了$a^{A\left \lceil p \right \rceil-B}\equiv b \pmod p$</p>
<p>容易发现，$a^{-B}$可以移到式子的右边</p>
<p>所以式子变成了$a^{A\left \lceil p \right \rceil} \equiv a^{B}b \pmod p$</p>
<p>并且，容易发现$A,B$均小于等于$\sqrt p$</p>
<p>所以我们首先枚举$B$，将$a^ib \bmod p$的值用<code>map</code>或<code>hash</code>或<code>unordered_map</code>存储下来</p>
<p>然后再枚举$A$，找到的第一个就是最小的，答案为$i\times\left \lceil p \right \rceil-k$</p>
<p>所以我们就找到了$a^x\equiv b \pmod p$的最小整数解$x$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">BSGS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,a,b,q;</span><br><span class="line">    m=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>,t=b;i&lt;=m;i++,t=t*a%p) rec[t]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>,tt=<span class="built_in">ksm</span>(a,m),t=tt;i&lt;=m;i++,t=t*tt%p) </span><br><span class="line">    	<span class="keyword">if</span> (rec[t]) <span class="keyword">return</span> i*m-rec[t];</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>众所周知，数论中的算法总会有个EX++++++++++的版本</p>
<p>而这个超进化，从<del>阉割版</del>正常版变成<del>普通版</del>EX版的条件一般是模数$p$与某数是否互质或$p$为素数</p>
<h3 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h3><p>求$a^x\equiv b \pmod p$的最小正整数解$x$</p>
<p>要求：$\gcd(a,p)$不一定等于$1$</p>
<p>和$exLucas$很像，我们首先得想办法将$\gcd(a,b)$变成$1$</p>
<p>具体的，我们令$d_1=\gcd(a,p)$，若$d_1 \nmid b$，无解</p>
<p><del>咕咕咕</del></p>
<p>然后每次我们将$a’=a\div d_1,p’=p\div d_1,b’=b\div d_1$，直到$\gcd(a’,p’)=1$，假设进行了$k$次</p>
<p>不妨设$D=\prod\limits_{i=1}^{k}d_i$</p>
<p>这个式子就变成了$\frac {a} {D}\times a^{x-k}\equiv\frac {b} {D} \pmod{\frac {p} {D}}$</p>
<p>此时$\gcd(\frac {a}{D},\frac {p} {D})=1$，跑一次<del>阉割</del>普通版$BSGS$就可以了，最后答案要加$k$</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b&amp;<span class="number">1</span>)</span><br><span class="line">            res=res*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n,<span class="type">int</span> p,<span class="type">int</span> ad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rec.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> m=std::<span class="built_in">ceil</span>(std::<span class="built_in">sqrt</span>(p));</span><br><span class="line">	<span class="type">int</span> s=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++,s=<span class="number">1ll</span>*s*a%p) rec[<span class="number">1ll</span>*s*n%p]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,tmp=s,s=ad;i&lt;=m;i++,s=<span class="number">1ll</span>*s*tmp%p)</span><br><span class="line">		<span class="keyword">if</span>(rec.<span class="built_in">find</span>(s)!=rec.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span>*i*m-rec[s]&gt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1ll</span>*i*m-rec[s];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">exBSGS</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a%=p,n%=p;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span> || p==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,d=<span class="number">1</span>,ad=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((d=<span class="built_in">gcd</span>(a,p))^<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n%d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        cnt++;n/=d,p/=d;</span><br><span class="line">        ad=(<span class="number">1ll</span>*ad*a/d)%p;</span><br><span class="line">		<span class="keyword">if</span>(ad==n) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">BSGS</span>(a,n,p,ad);</span><br><span class="line">    <span class="keyword">if</span> (res==<span class="number">-1</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">return</span> res+cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>题目：124 OJ 1226</p>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>建站小记</title>
    <url>/2023/02/11/tmp/</url>
    <content><![CDATA[<p>成功建站于2023/2/11，复习调研考试前</p>
<span id="more"></span>
<p>have fun!</p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2023/02/11/wll/</url>
    <content><![CDATA[<p>网络流学习笔记</p>
<span id="more"></span>
<p>注意要点：</p>
<p>$1.$费用流</p>
<p>用$SPFA$，记住不要<code>v==t</code>就<code>return 1</code>，松弛完毕后再判断。</p>
<p>运行$Dinic$的时候，记住要打$vis_i$标记，离开节点$u$，遍历出边应清空$vis$，判断$vis$。</p>
<p>加上<code>ret+=k*edge[i].c</code>，判断的时候记住<code>d[v]==d[u]+edge[i].w</code>，<code>for</code>循环记得判断<code>f&gt;0</code>，然后记得建双向边（一个容量变为$0$，一个费用变成了原来的相反数）</p>
<p>$2.$牢记点：</p>
<p>$a.$网络流一般对模板没有考察，考察在于建图，对图建模上。牢记网络流思维模型，认真思考，切记不要改动板子（除非像是记录<code>pre</code>等前驱点）</p>
<p>$b.$做题中心在于费用流上，思考区别</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>$Dinic$算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline int BFS()//BFS最短路增广</span><br><span class="line">&#123;</span><br><span class="line">	queue &lt;int&gt; q;	</span><br><span class="line">	memset(d,0x3f,sizeof(d));</span><br><span class="line">	memcpy(cur,head,sizeof(head));</span><br><span class="line">	q.push(s);d[s]=0;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int u=q.front();q.pop();</span><br><span class="line">		for (int i=head[u];i;i=edge[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			int v=edge[i].v;</span><br><span class="line">			if (d[v]==INF &amp;&amp; edge[i].w)</span><br><span class="line">			&#123;</span><br><span class="line">				q.push(v);</span><br><span class="line">				d[v]=d[u]+1;//对图进行分层</span><br><span class="line">				if (v==t) return 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">inline int Dinic(int u,int f)</span><br><span class="line">&#123;</span><br><span class="line">	if (u==t) return f;</span><br><span class="line">	int k,res=0;</span><br><span class="line">	for (int i=cur[u];i &amp;&amp; f;i=edge[i].next)//剪枝</span><br><span class="line">	&#123;</span><br><span class="line">		int v=edge[i].v;cur[u]=i;//当前弧优化</span><br><span class="line">		if (d[v]==d[u]+1 &amp;&amp; edge[i].w)</span><br><span class="line">		&#123;</span><br><span class="line">			k=Dinic(v,min(edge[i].w,f));</span><br><span class="line">			if (!k) &#123;d[v]=INF;continue;&#125;//剪枝</span><br><span class="line">			edge[i].w-=k,edge[i^1].w+=k;//调整边权</span><br><span class="line">			f-=k,res+=k;//流量</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$Dinic$算法在$EK$算法上改进而来，通过对图分层，求最短路来进行增广，最多会增广$n$次，单次最劣复杂度为$\Theta(nm)$，总时间复杂度$\Theta(n^2m)$</p>
<p><del>背个板子就可以了</del></p>
<h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><p>$1.$全局</p>
<p>咕咕咕</p>
<p>$1.$ $s-&gt;t$最小割</p>
<p>根据最大流最小割定理，最大流=最小割</p>
<p>所以套一次$Dinic$求出来就可以力</p>
<h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><p>$SSP$</p>
<p><del>不会，咕咕咕</del></p>
<p>只会用$SPFA+Dinic$的$SSP$捏qwq</p>
<p>实际上只用把$bfs$改成$SPFA$，加个<code>vis</code>数组就可以力，而且<code>vis</code>可以$Dinic$和$SPFA$通用，好耶！</p>
<p>注意点:</p>
<p>$a.$注意$SPFA$全部松弛完后（不是<code>v==t</code>）才<code>return</code></p>
<p>$b.$ $Dinic$进入点$u$离开点$u$注意打上标记&amp;取消标记</p>
<p>$c.$判断能不能继续递归的时候也要判断点没在递归栈内(<code>!vis[v]</code>)</p>
<p>$SPFA$实现的$SSP$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline int SPFA()</span><br><span class="line">&#123;</span><br><span class="line">	queue &lt;int&gt; q;</span><br><span class="line">	memset(d,0x3f,sizeof(d));</span><br><span class="line">	memcpy(cur,head,sizeof(head));</span><br><span class="line">	q.push(s),d[s]=0;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int u=q.front();q.pop();</span><br><span class="line">		vis[u]=0;</span><br><span class="line">		for (int i=head[u];i;i=edge[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			int v=edge[i].v;</span><br><span class="line">			if (d[v]&gt;d[u]+edge[i].c &amp;&amp; edge[i].w)</span><br><span class="line">			&#123;</span><br><span class="line">				d[v]=d[u]+edge[i].c;</span><br><span class="line">				if (!vis[v])</span><br><span class="line">				&#123;</span><br><span class="line">					q.push(v);</span><br><span class="line">					vis[v]=1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return d[t]==INF?0:1;</span><br><span class="line">&#125;</span><br><span class="line">inline int Dinic(int u,int f)</span><br><span class="line">&#123;</span><br><span class="line">	if (u==t) return f;</span><br><span class="line">	vis[u]=1;int k,res=0;</span><br><span class="line">	for (int i=cur[u];i &amp;&amp; f;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		int v=edge[i].v;cur[u]=i;</span><br><span class="line">		if (edge[i].w &amp;&amp; d[v]==d[u]+edge[i].c &amp;&amp; !vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			k=Dinic(v,min(f,edge[i].w));</span><br><span class="line">			if (k)</span><br><span class="line">			&#123;</span><br><span class="line">				edge[i].w-=k;</span><br><span class="line">				edge[i^1].w+=k;</span><br><span class="line">				res+=k,f-=k;</span><br><span class="line">				ret+=k*edge[i].c;</span><br><span class="line">			&#125;</span><br><span class="line">			else d[v]=INF;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[u]=0;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$Primal-Dual$</p>
<p>和$Johnson$一样换个元跑$dijkstra$就行了，不过没写过/kk</p>
<p>经典例题：网络流24题</p>
<p>常见建模：</p>
<p>$1.$二分图的最大独立集</p>
<p>例题：骑士共存问题，长脖子鹿，方格取数</p>
<p>通过黑白拆点，奇偶性划分，建出$s-&gt;0-&gt;1-&gt;t$的模型</p>
<p>常用：棋盘类</p>
<p>$2.$拆为入点，出点</p>
<p>例题：逃跑，蜥蜴</p>
<p>通过拆点，将图上的点权考虑转化为边权，并通过出点入点实现某些性质</p>
<p>常用：点权转边权类</p>
<p>$3.$将不同物品分开罗列，互相连边</p>
<p>类似于黑白染色，但是可能有多种物品$(\geq2)$，考虑分开罗列，按照题目所给条件飞开连权值为$w$（如只能用一次等条件时，$w=1$）的边</p>
<p>例题：酒店之王，教辅的组成</p>
<p>$4.$费用流</p>
<p>看似最大流，实际费用流</p>
<p>注意细节</p>
<p>例题：任务分配</p>
<p>$5.$向同种物品连边</p>
<p>体现类似“流动性”，转移，向同类连边</p>
<p>例题：猪</p>
<p>$6.$记录前后驱</p>
<p>用<code>pre</code>数组或检查边权为$0$的边</p>
<p>例题：圆桌问题，飞行员配对方案</p>
<p>$7.$最小割</p>
<p>最大流=最小割</p>
<p>$Dinic$求出最小割即可</p>
<p>注意$CF103E$  $Buying Sets$这题比较神，用$Lim-w$记录边权，$ans$设置为一个极大的数，最后减去$Dinic$的答案，值得思考。</p>
<p>例题：奶牛的电信，$CF103E$  $Buying Sets$</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>关于上下界的学习笔记：</p>
<p><del>咕咕咕喵喵喵</del></p>
]]></content>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Revolution</title>
    <url>/2023/02/12/Revolution/</url>
    <content><![CDATA[<p>Revolution</p>
<span id="more"></span>
<p>革命 佚辰<br>巨大的灰色乌云笼罩在灰色的、各式各样的建筑之上，炫目的LED灯管被竖直放置于C市的各个角落。深灰的马路上粉刷着浅灰的虚线和实线，引导着川流不息、来来往往的车辆与人群。 C市的一天，便这样开始了。 2050年，地球环境进一步恶化，人类生存资源濒临枯竭，即使科技再高速发展也无济于事。但此时，人类的基因已经完全破译，每个区段每一对碱基对控制着什么形状早已能够被识别、控制与修改。为了维护社会秩序，掌管C市的P党在该技术萌芽时便花重金将专利从相关公司手中买下，垄断了这一技术。所以，这达成了P党内部核心人员一个心照不宣的秘密。 15年前。巨大的双链DNA模型在房间内投影出来，右旋的优美轮廓让在场的所有科学家都赞叹不已。喧哗声中，一个人走上演讲台，调试好麦克风，开始了它的发言。 “大家好。正如大家所知，人的眼睛是根据所看见光的波长来识别颜色的，而可见光谱中的大部分颜色可以由三种基本色光红、绿、蓝按不同比例混合而成，形成了连续的可视光谱。人类肉眼能区分其中的几百万至一千万种。经过十余年的研究，我们发现人类基因中关于色彩识别的区段较为冗长；为降低生活成本，我代表P党在此宣布自今年1月1日00:00起将C市所有居民基因中的色彩识别区段删除，仅保留黑白两种基本色光。同时，相关政策也将陆续实施，感谢各位的理解与支持。” …… 2034年12月31日，23:58。此时，C市的广大人民群众还不知道他们即将面临什么，有的已早早入睡，有的还在五彩斑斓的繁华都市中享受着绚烂多彩的生活。市中心高楼上的始终嘀嗒，分针逐渐指向了12的正下方。 00:00。 所有还醒着的人们的记忆模块被完全刷新。 “这是一个非黑即白的世界。” “灰色由不同比例的黑白色组成，是最常见的一种颜色。” “自古以来便是这样。” 所以，这场历史性的革命在悄无声息中圆满完成了。没有骚动，没有恐慌。 与此同时，电子课本、电子词典被同步刷新。颜料标签被迅速替换。文字与影像资料被大幅度删改，相关学科被取消。红、黄、绿灯依次换为圆形、方形、三角形灯。颜色引导标识改为黑白点线面组合引导标识。 …… 一切的一切，归零。 生活照常。 2030年，C市成为E国少数几个未通过《全可视区段色彩使用法案》的国家。P党声称此法案与C市传统颜色阶级制度价值观不符，不利于人口增长，可能引发社会混乱。此前，C市已出现多次因争取全区段可视色彩使用权而导致舆论风波的现象，重重封锁也无济于事。同时，其声称外部势力也在对C市青少年以各种潜移默化的方式渗透色彩多元化共存理论，造成了巨大影响。为了彻底解决这一问题，P党最后做出了取消色彩可视化这一决定，才有了这场看似荒谬的颜色革命。 雨后，晴空。天边罕见地出现了一道彩虹，只是再也无法被C市的孩子们看见了。但他们还从课本上了解过这一自然景观，它被称为“灰虹”，天空中呈现了七种不同深浅的黑白色条带，蔚为壮观。 小朋友们发出天真无邪的笑声，在浅灰的草坪上和父母一起欣赏美丽的灰虹。 风也轻轻。 …… 但那无法被看见色彩的彩虹，它还存在着啊。幸好，C市的科学还没有发展到能将彩虹粉刷为黑白的地步，幸好，它改变的只是我们人类本身。不论你是否承认彩虹的赤橙黄绿青蓝紫，它都存在着，从古至今。只是对C市的人来说，看不见了罢。 带着无色的双眼去看待这个世界，世界当然是没有颜色的啊。 或许会问，为什么那些所谓的“外部势力”没有到C市来宣传呢？ 因为C市早已故步自封了呢。C市早已在城郊筑好了高墙，外部势力很难进入，内部民众也难以出去。大家的梯子都被没收了，那可是违法的啊。 从前，颜色是有阶级限制的，P党内部核心人员身穿黄色，大官穿紫色，小吏穿青绿色，平民穿灰白色。倘若僭越，是要遭来杀身之祸的。现在可好，民主、自由、平等，大家都一样，没人管你穿什么颜色，只是深深浅浅罢了。果然，社会进步，百姓安康。 深夜，高楼。P党那位发表演讲的科学家站在窗边，望着依旧五光十色的建筑，冷笑一声，又走进无边的黑暗。 …… “又经过几年的研究，我们发现人类基因中关于色彩识别的区段没有其存在的必要性。为进一步降低生活生产成本，我代表P党在此宣布自今年1月1日00:00起将C市所有居民基因中色彩识别区段全部删除。同时，相关政策也将陆续实施。”“感谢各位的理解与支持。” 00:00。 C市的人全都瞎了。 没有骚动，没有恐慌。</p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay Tree学习笔记</title>
    <url>/2023/02/12/Splay/</url>
    <content><![CDATA[<p>Splay Tree’s Introduction</p>
<span id="more"></span>
<h2 id="Splay-树简介"><a href="#Splay-树简介" class="headerlink" title="$Splay$树简介"></a>$Splay$树简介</h2><p>$Splay$树是伸展树，一种平衡树</p>
<p>相较于$Treap$的随机编号，$Splay$的$splay$操作可以有效地将树高保持在$\log n$</p>
<p>首先要有二叉搜索树的性质，即$\forall u,lson(u) &lt; rson(u)$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>维护物</th>
<th>子树大小</th>
<th>左右儿子</th>
<th>父亲</th>
<th>数的个数</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><code>get</code>操作：判断点是左儿子还是右儿子</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="type">int</span> fa=t[x].fa;<span class="keyword">return</span> x==t[fa].ch[<span class="number">1</span>];&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>pushup</code>操作：统计子树大小</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;t[u].son=t[t[u].ch[<span class="number">1</span>]].son+t[t[u].ch[<span class="number">0</span>]].son+t[u].cnt;&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>rotate</code>操作：左旋，右旋</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=t[x].fa,z=t[y].fa;</span><br><span class="line">    <span class="type">int</span> chk=<span class="built_in">get</span>(x);</span><br><span class="line">    t[y].ch[chk]=t[x].ch[chk^<span class="number">1</span>],t[t[y].ch[chk]].fa=y;</span><br><span class="line">    t[x].ch[chk^<span class="number">1</span>]=y,t[y].fa=x,t[x].fa=z;</span><br><span class="line">    <span class="keyword">if</span> (z) t[z].ch[t[z].ch[<span class="number">1</span>]==y]=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y),<span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>分析一下旋转操作：</p>
<p>$1.$将$y$原来的儿子$x$的位置变成$x$的儿子，将这个点指向$y$</p>
<p>$2.$将$x$的另一个儿子指向$y$，$y$的父亲指向$x$，$x$的父亲指向$y$</p>
<p>$3.$如果$y$原来的父亲$z$存在，就将$z$原来$y$所处儿子的位置指向$x$</p>
<p>$4.$重新计算$y,x$的子树大小</p>
<p>$Q:$为什么先算$y$？</p>
<p>$A:$ $x$的子树大小依赖于$y$，这样保证答案正确</p>
<h2 id="Splay-操作"><a href="#Splay-操作" class="headerlink" title="$Splay$操作"></a>$Splay$操作</h2><p>这块便是$Splay$树的精华</p>
<p>我们通过$Splay$操作，保证了树高为$\log n$</p>
<p>这里有一个规定：每访问一个点$u$，就要将$u$旋转至$root$</p>
<p>这里一共有三种操作$zig,zig-zig,zig-zag$</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span>&amp; goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fa=t[goal].fa;</span><br><span class="line">    <span class="keyword">while</span> (fa!=t[u].fa)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[t[x].fa].fa!=f)</span><br><span class="line">            <span class="built_in">rotate</span>(<span class="built_in">get</span>(x)==<span class="built_in">get</span>(t[x].fa)?t[x].fa:x);</span><br><span class="line">       	<span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    goal=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入算是一个比较复杂的操作</p>
<p>首先需要判断是否非空，若为空，插入$root$</p>
<p>其次，需要判断点是否存在，存在则<code>t[u].cnt++</code></p>
<p>否则，则插入节点$u$</p>
<p>注意每次都要进行<code>splay</code>和<code>pushup</code>操作</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        root=++tot;</span><br><span class="line">        t[root].val=x;</span><br><span class="line">        t[root].cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">pushup</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u,fa;</span><br><span class="line">    u=fa=root;</span><br><span class="line">    <span class="keyword">while</span> (u &amp;&amp; t[u].val!=x) fa=u,u=t[u].ch[x&gt;val];</span><br><span class="line">    <span class="keyword">if</span> (!u)<span class="comment">//不存在，新插入u</span></span><br><span class="line">    &#123;</span><br><span class="line">        u=++tot;</span><br><span class="line">        t[u].val=x;</span><br><span class="line">        t[u].cnt=<span class="number">1</span>;</span><br><span class="line">        t[u].fa=fa;</span><br><span class="line">        t[fa].ch[x&gt;t[fa].x]=x;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">        <span class="built_in">splay</span>(u,root);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存在</span></span><br><span class="line">    t[u].cnt++;</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">    <span class="built_in">splay</span>(u,root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除也是一个比较复杂的操作</p>
<p>考虑将点$u$旋至$root$，然后根据<code>cnt</code>已经左右子树情况分类讨论</p>
<p>$1.$<code>cnt&gt;1</code>，考虑将<code>cnt--</code></p>
<p>$2.$<code>cnt==1</code>，左，右子树均为空，树为空</p>
<p>$3.$<code>cnt==1</code>，左子树为空，右子树为根。右子树有空同理</p>
<p>$4.$<code>cnt==1</code>，左右均不为空，去左子树最大元素为根（先向左后一直向右到叶子）</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">rank</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (t[root].cnt&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[root].cnt--;</span><br><span class="line">        <span class="built_in">pushup</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!t[root].ch[<span class="number">0</span>] &amp;&amp; !t[root].ch[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        t[root].<span class="built_in">clear</span>();</span><br><span class="line">        root=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!t[root].ch[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        root=t[root].ch[<span class="number">1</span>];</span><br><span class="line">        t[root].fa=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!t[root].ch[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        root=t[root].ch[<span class="number">0</span>];</span><br><span class="line">        t[root].fa=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=t[root].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (t[u].ch[<span class="number">1</span>])</span><br><span class="line">        	u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">splay</span>(u,t[root].ch[<span class="number">0</span>]);</span><br><span class="line">        t[u].ch[<span class="number">1</span>]=t[root].ch[<span class="number">1</span>];</span><br><span class="line">        t[t[root].ch[<span class="number">1</span>]].fa=u;t[u].fa=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">        root=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="查询前驱后继"><a href="#查询前驱后继" class="headerlink" title="查询前驱后继"></a>查询前驱后继</h2><p>对于值$x$，如果$x&gt;val_u$，则往右子树查找，否则往左子树查找</p>
<p>基于此，我们可以查询前驱，后继。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res,u=root;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x&gt;t[u].val)</span><br><span class="line">        &#123;</span><br><span class="line">            res=t[u].val;</span><br><span class="line">            u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> u=t[u].ch[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res,u=root;</span><br><span class="line">    <span class="keyword">while</span> (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;t[u].val)</span><br><span class="line">        &#123;</span><br><span class="line">            res=t[u].val;</span><br><span class="line">            u=t[u].ch[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="查询-x-的排名"><a href="#查询-x-的排名" class="headerlink" title="查询$x$的排名"></a>查询$x$的排名</h2><p>将点$u$找到后翻到根，然后记录左子树<code>size+1</code>就是答案</p>
<p>或者可以根据二叉搜索树的性质来搞，一样的</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,u=root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;t[u].val)</span><br><span class="line">            u=t[u].ch[<span class="number">0</span>];</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res+=t[t[u].ch[<span class="number">0</span>]].son;</span><br><span class="line">            <span class="keyword">if</span> (x==t[u].val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">splay</span>(u,root);</span><br><span class="line">                <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=t[u].cnt;</span><br><span class="line">            u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="查询排名为-k-的数"><a href="#查询排名为-k-的数" class="headerlink" title="查询排名为$k$的数"></a>查询排名为$k$的数</h2><p>对于排名为$k$，我们不妨考虑一直减去左子树中小于它的数，当$k\leq0$时，即为答案</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[u].ch[<span class="number">0</span>] &amp;&amp; k&lt;=t[u].son)</span><br><span class="line">            u=t[u].ch[<span class="number">0</span>];</span><br><span class="line">       	<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k-=t[t[u].ch[<span class="number">0</span>]].son-t[u].cnt;</span><br><span class="line">            <span class="keyword">if</span> (k&lt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">splay</span>(u,root);</span><br><span class="line">                <span class="keyword">return</span> t[u].val;</span><br><span class="line">            &#125;</span><br><span class="line">            u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">namespace</span> Splay&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">        <span class="type">int</span> ch[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        <span class="type">int</span> son;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> fa;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ch[<span class="number">1</span>]=ch[<span class="number">0</span>]=cnt=son=val=fa=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;t[N];</span><br><span class="line">    <span class="type">int</span> root=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;t[u].son=t[t[u].ch[<span class="number">0</span>]].son+t[t[u].ch[<span class="number">1</span>]].son+t[u].cnt;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="type">int</span> fa=t[x].fa;<span class="keyword">return</span> t[fa].ch[<span class="number">1</span>]==x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> y=t[x].fa,z=t[y].fa;</span><br><span class="line">        <span class="type">int</span> chk=<span class="built_in">get</span>(x);</span><br><span class="line">        t[y].ch[chk]=t[x].ch[chk^<span class="number">1</span>],t[t[y].ch[chk]].fa=y;</span><br><span class="line">        t[x].ch[chk^<span class="number">1</span>]=y,t[y].fa=x;t[x].fa=z;</span><br><span class="line">        <span class="keyword">if</span> (z) t[z].ch[t[z].ch[<span class="number">1</span>]==y]=x;</span><br><span class="line">        <span class="built_in">pushup</span>(y),<span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> &amp;goal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> f=t[goal].fa;</span><br><span class="line">        <span class="keyword">while</span> (t[x].fa!=f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[t[x].fa].fa!=f)</span><br><span class="line">                <span class="built_in">rotate</span>(<span class="built_in">get</span>(x)==<span class="built_in">get</span>(t[x].fa)?t[x].fa:x);</span><br><span class="line">            <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        goal=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            root=++tot;</span><br><span class="line">            t[root].val=x;</span><br><span class="line">            t[root].cnt=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(root);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> u,fa;</span><br><span class="line">        u=fa=root;</span><br><span class="line">        <span class="keyword">while</span> (u &amp;&amp; t[u].val!=x) fa=u,u=t[u].ch[x&gt;t[u].val];</span><br><span class="line">        <span class="keyword">if</span> (!u)</span><br><span class="line">        &#123;</span><br><span class="line">            u=++tot;</span><br><span class="line">            t[u].cnt=<span class="number">1</span>;</span><br><span class="line">            t[u].val=x;</span><br><span class="line">            t[u].fa=fa;</span><br><span class="line">            t[fa].ch[x&gt;t[fa].val]=u;</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">            <span class="built_in">splay</span>(u,root);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        t[u].cnt++;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">        <span class="built_in">splay</span>(u,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>,u=root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;t[u].val) </span><br><span class="line">                u=t[u].ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res+=t[t[u].ch[<span class="number">0</span>]].son;</span><br><span class="line">                <span class="keyword">if</span> (x==t[u].val) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">splay</span>(u,root);</span><br><span class="line">                    <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res+=t[u].cnt;</span><br><span class="line">                u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> u=root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[u].ch[<span class="number">0</span>] &amp;&amp; k&lt;=t[t[u].ch[<span class="number">0</span>]].son)</span><br><span class="line">                u=t[u].ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k-=t[u].cnt+t[t[u].ch[<span class="number">0</span>]].son;</span><br><span class="line">                <span class="keyword">if</span> (k&lt;=<span class="number">0</span>)   </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">splay</span>(u,root);</span><br><span class="line">                    <span class="keyword">return</span> t[u].val;</span><br><span class="line">                &#125;</span><br><span class="line">                u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res,u=root;</span><br><span class="line">        <span class="keyword">while</span> (u)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x&gt;t[u].val)</span><br><span class="line">            &#123;</span><br><span class="line">                res=t[u].val;</span><br><span class="line">                u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> u=t[u].ch[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res,u=root;</span><br><span class="line">        <span class="keyword">while</span> (u)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x&lt;t[u].val)</span><br><span class="line">            &#123;</span><br><span class="line">                res=t[u].val;</span><br><span class="line">                u=t[u].ch[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">rank</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (t[root].cnt&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t[root].cnt--;</span><br><span class="line">            <span class="built_in">pushup</span>(root);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!t[root].ch[<span class="number">0</span>] &amp;&amp; !t[root].ch[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            t[root].<span class="built_in">clear</span>();</span><br><span class="line">            root=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t[root].ch[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            root=t[root].ch[<span class="number">1</span>];</span><br><span class="line">            t[root].fa=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!t[root].ch[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            root=t[root].ch[<span class="number">0</span>];</span><br><span class="line">            t[root].fa=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u=t[root].ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span> (t[u].ch[<span class="number">1</span>])</span><br><span class="line">                u=t[u].ch[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">splay</span>(u,t[root].ch[<span class="number">0</span>]);</span><br><span class="line">            t[u].ch[<span class="number">1</span>]=t[root].ch[<span class="number">1</span>];</span><br><span class="line">            t[t[root].ch[<span class="number">1</span>]].fa=u;t[u].fa=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">pushup</span>(u);</span><br><span class="line">            root=u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Splay;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) &#123;f=<span class="number">-1</span>;&#125; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> s*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>,sta[<span class="number">35</span>];</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;sta[top++]=x%<span class="number">10</span>,x/=<span class="number">10</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span>(top) &#123;<span class="built_in">putchar</span>(sta[--top]+<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">del</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">            <span class="type">int</span> res=Splay::<span class="built_in">rank</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">            <span class="type">int</span> res=<span class="built_in">kth</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">            <span class="type">int</span> res=<span class="built_in">pre</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">            <span class="type">int</span> res=<span class="built_in">next</span>(x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>data-structure</tag>
      </tags>
  </entry>
</search>
